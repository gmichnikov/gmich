{% extends "base.html" %}

{% block title %}Edit: {{ note.title }}{% endblock %}

{% block styles %}
<link rel="stylesheet" href="{{ url_for('notes.static', filename='notes.css') }}">
{% endblock %}

{% block content %}
<div class="notes-page">
    <div class="notes-container">
        <a href="{{ url_for('notes.index') }}" class="notes-back-link">‚Üê Back to Notes</a>

        <div class="notes-header">
            <h1 class="notes-title">Edit Note</h1>
            <span id="save-indicator" style="color: var(--notes-text-muted); font-size: 0.9rem;"></span>
        </div>

        <form id="edit-form" class="notes-card" style="padding: 24px;">

            <div class="notes-form-group">
                <label for="title" class="notes-label">Title</label>
                <input type="text" id="title" name="title" class="notes-input"
                       value="{{ note.title }}" required>
                {% if error %}
                <p class="notes-error">{{ error }}</p>
                {% endif %}
            </div>

            <div class="notes-form-group">
                <label for="content" class="notes-label">Content (Markdown supported)</label>
                <textarea id="content" name="content" class="notes-textarea">{{ note.content }}</textarea>
            </div>

            <div class="notes-form-actions">
                <button type="submit" class="notes-btn notes-btn-primary">Save</button>
                <button type="button" id="save-and-view-btn" class="notes-btn notes-btn-secondary">Save & View</button>
                <a href="{{ url_for('notes.index') }}" class="notes-btn notes-btn-secondary">Back to Notes</a>
            </div>
        </form>
    </div>
</div>

<script>
const form = document.getElementById('edit-form');
const titleInput = document.getElementById('title');
const contentInput = document.getElementById('content');
const saveIndicator = document.getElementById('save-indicator');
const noteId = '{{ note.id }}';
const csrfToken = document.querySelector('meta[name="csrf-token"]').getAttribute('content');
const viewUrl = '{{ url_for("notes.view", note_id=note.id) }}';

// Track last saved state
let lastSavedTitle = titleInput.value;
let lastSavedContent = contentInput.value;
let autosaveTimer = null;
let isSaving = false;

function hasUnsavedChanges() {
    return titleInput.value !== lastSavedTitle || contentInput.value !== lastSavedContent;
}

function updateIndicator(status, message) {
    saveIndicator.textContent = message;
    if (status === 'unsaved') {
        saveIndicator.style.color = 'var(--notes-text-muted)';
    } else if (status === 'saving') {
        saveIndicator.style.color = 'var(--notes-accent)';
    } else if (status === 'saved') {
        saveIndicator.style.color = 'var(--notes-success)';
    } else if (status === 'error') {
        saveIndicator.style.color = 'var(--notes-error)';
    }
}

async function performSave(redirectAfter = false) {
    const title = titleInput.value.trim();
    const content = contentInput.value;

    // Don't save if title is empty
    if (!title) {
        updateIndicator('error', 'Title cannot be empty');
        titleInput.focus();
        return false;
    }

    // Don't save if nothing changed (but still show "Saved" for user feedback)
    if (!hasUnsavedChanges()) {
        updateIndicator('saved', 'Saved');
        if (redirectAfter) {
            window.location.href = viewUrl;
        }
        return true;
    }

    // Clear any pending autosave
    if (autosaveTimer) {
        clearTimeout(autosaveTimer);
        autosaveTimer = null;
    }

    isSaving = true;
    updateIndicator('saving', 'Saving...');

    try {
        const response = await fetch(`/notes/api/${noteId}/autosave`, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'X-CSRFToken': csrfToken
            },
            body: JSON.stringify({ title, content })
        });

        const data = await response.json();

        if (response.ok && data.status === 'success') {
            lastSavedTitle = title;
            lastSavedContent = content;
            updateIndicator('saved', 'Saved');
            if (redirectAfter) {
                window.location.href = viewUrl;
            }
            return true;
        } else {
            updateIndicator('error', data.message || 'Save failed');
            return false;
        }
    } catch (error) {
        updateIndicator('error', 'Save failed');
        return false;
    } finally {
        isSaving = false;
    }
}

function scheduleAutosave() {
    // Clear existing timer
    if (autosaveTimer) {
        clearTimeout(autosaveTimer);
    }

    // Show unsaved indicator if content changed
    if (hasUnsavedChanges()) {
        updateIndicator('unsaved', 'Unsaved changes');
    }

    // Schedule autosave for 3 seconds from now
    autosaveTimer = setTimeout(() => performSave(false), 3000);
}

// Listen for changes on title and content
titleInput.addEventListener('input', scheduleAutosave);
contentInput.addEventListener('input', scheduleAutosave);

// Intercept form submit to use AJAX instead
form.addEventListener('submit', function(e) {
    e.preventDefault();
    performSave(false);
});

// Ctrl+S / Cmd+S to save
document.addEventListener('keydown', function(e) {
    if ((e.ctrlKey || e.metaKey) && e.key === 's') {
        e.preventDefault();
        performSave(false);
    }
});

// Save & View button
document.getElementById('save-and-view-btn').addEventListener('click', function() {
    performSave(true);
});
</script>
{% endblock %}
